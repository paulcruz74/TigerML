Handling Comments

In order to handle comments, our lexer uses a state machine. From the initial state, if the lexer sees the opening for a comment (/*) it transitions into the comment state. Within the comment state, we can have nested comments. We handle this by incrementing a counter (commentCount) each time that we are in the comment state and see an opening for another comment (/*). Within comments, anything besides the comment-opening (/*) is ignored by simply continuing parsing. Whenever a comment-close (*/) is seen while in the comment state, we decrement commentCount. If commentCount is zero after decrementing, we then exit the comment state and return to the initial state where things can be lexed normally again. If commentCount is not zero after decrementing, we stay in the comment state. Determining if comments are closed is explained in the Handling EOF section.

Handling Strings

Strings are handled somewhat similarly to comments. From the initial state, if we see quotation marks, we enter the string state. In order to keep track of various information related to the string, we also set inString to 1 (basically a boolean value that tracks whether or not we're in string state), stringAccum is set to the empty string (keeps track of which characters are actually in the string), and stringStartPos (the starting position of the string). There are various escape characters that are allowed in strings that need to be translated into their actual values when the lexer runs, which is why we keep track of stringAccum. For any of these escape characters that are listed in the appendix, we translate the escape character into its actual value and append it to stringAccum (which is now basically a running tab of characters that are part of the string).  We also check for escape sequences that are not listed in the appendix as valid. If our lexer detects escape sequences that are not valid, then we output an error. Finally, for any other characters not mentioned above, we simply append them to stringAccum. When another set of quotations is detected while in the string state, we create a string token using stringAccum, the starting position, and yypos. (note that we check for backslash-quotations independently and therefore these will not break us out of the string, so we can have strings like "abdsfd \"\n something \"something "). Detecting unclosed strings is explained in the Handling EOF section.

Handling Errors

For handling errors in the initial state, we simply check for any characters that do not fit our assigned patterns (we put a "." regex at the bottom of the list). This ensures that any characters that are not valid throw an error (this is done using the ErrorMsg.error function that is provided to us). There are no errors in comments since anything is a valid comment. The only errors we had to check for in strings is the use of invalid escape sequences. We do so by adding an additional check (\\.) which ensures that any escape sequence that we have not explicitly mentioned will be caught and will throw an error.

Handling EOF

We do several things when handling EOF. First, we check to make sure that commentCount = 0. This tells us whether or not there are unclosed comments in the file. If there are, we output an error (and reset variables associated with comments). Secondly, we check to see that inString = 0. This is to verify that we have closed strings at the end of the file. Similarly, if we detect an open string, we throw an error. Lastly, if those two checks pass, we create an EOF token.

